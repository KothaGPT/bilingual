#!/usr/bin/env python3
"""Project Review and Coverage Analysis Script

This script performs the following actions for the bilingual project:
1. Detects functions/methods that are placeholders (e.g., contain only `pass`, `...`, or raise `NotImplementedError`).
2. Executes the test suite with coverage collection.
3. Parses the generated `coverage.xml` to compute per‑file coverage and identifies files with coverage below a threshold.
4. Generates a human‑readable report `PROJECT_REVIEW.md` summarising missing implementations and coverage gaps.

The script is intended to be run from the repository root.
"""

import ast
import os
import subprocess
import sys
import xml.etree.ElementTree as ET
from pathlib import Path

PROJECT_ROOT = Path(__file__).resolve().parents[1]
SRC_DIR = PROJECT_ROOT / "src" / "bilingual"
COVERAGE_XML = PROJECT_ROOT / "coverage.xml"
REPORT_PATH = PROJECT_ROOT / "PROJECT_REVIEW.md"

COVERAGE_THRESHOLD = 80.0

def find_placeholder_functions():
    """Return a list of (file_path, function_name, line_no) for functions that appear to be unimplemented.
    A placeholder is defined as a function whose body consists solely of one of:
    - `pass`
    - `...` (Ellipsis)
    - `raise NotImplementedError`
    """
    placeholders = []
    for py_path in SRC_DIR.rglob("*.py"):
        try:
            tree = ast.parse(py_path.read_text())
        except Exception:
            continue
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                # ignore empty docstring only bodies
                if not node.body:
                    continue
                # Check for single statement bodies
                if len(node.body) == 1:
                    stmt = node.body[0]
                    if isinstance(stmt, ast.Pass):
                        placeholders.append((py_path, node.name, node.lineno))
                    elif isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Ellipsis):
                        placeholders.append((py_path, node.name, node.lineno))
                    elif isinstance(stmt, ast.Raise):
                        if isinstance(stmt.exc, ast.Call) and getattr(stmt.exc.func, "id", None) == "NotImplementedError":
                            placeholders.append((py_path, node.name, node.lineno))
    return placeholders

def run_tests_with_coverage():
    """Run pytest with coverage collection. Returns True if the command succeeded."""
    cmd = [sys.executable, "-m", "pytest", "-q", "--cov=bilingual", "--cov-report=xml"]
    result = subprocess.run(cmd, cwd=PROJECT_ROOT, capture_output=True, text=True)
    if result.returncode != 0:
        print("Tests failed or coverage generation error:")
        print(result.stdout)
        print(result.stderr, file=sys.stderr)
        return False
    return True

def parse_coverage_xml():
    """Parse coverage.xml and return a dict mapping file paths to coverage percentages."""
    if not COVERAGE_XML.is_file():
        return {}
    tree = ET.parse(COVERAGE_XML)
    root = tree.getroot()
    # The XML format follows the coverage.py schema.
    file_cov = {}
    for package in root.findall('.//packages/package'):
        for class_el in package.findall('classes/class'):
            filename = class_el.get('filename')
            lines = class_el.find('lines')
            if lines is None:
                continue
            total = 0
            covered = 0
            for line in lines.findall('line'):
                total += 1
                if int(line.get('hits', '0')) > 0:
                    covered += 1
            if total > 0:
                percent = (covered / total) * 100.0
                file_cov[PROJECT_ROOT / filename] = percent
    return file_cov

def generate_report(placeholders, coverage_dict):
    with REPORT_PATH.open('w') as f:
        f.write("# Project Review Report\n\n")
        f.write("## Missing / Placeholder Implementations\n\n")
        if placeholders:
            for path, func, line in placeholders:
                rel = path.relative_to(PROJECT_ROOT)
                f.write(f"- `{rel}`: function `{func}` at line {line} appears to be a placeholder.\n")
        else:
            f.write("No placeholder functions detected.\n")
        f.write("\n---\n\n")
        f.write("## Coverage Summary (threshold: {0:.0f}%)\n\n".format(COVERAGE_THRESHOLD))
        low_cov = {p: c for p, c in coverage_dict.items() if c < COVERAGE_THRESHOLD}
        if low_cov:
            for path, percent in sorted(low_cov.items(), key=lambda x: x[1]):
                rel = path.relative_to(PROJECT_ROOT)
                f.write(f"- `{rel}`: {percent:.1f}% coverage\n")
        else:
            f.write("All files meet the coverage threshold.\n")
        f.write("\n---\n\nGenerated by `scripts/project_review.py`.\n")

def main():
    print("Scanning for placeholder functions…")
    placeholders = find_placeholder_functions()
    print(f"Found {len(placeholders)} placeholder(s).")
    print("Running test suite with coverage…")
    if not run_tests_with_coverage():
        sys.exit(1)
    print("Parsing coverage report…")
    coverage_dict = parse_coverage_xml()
    print(f"Parsed coverage for {len(coverage_dict)} file(s).")
    print("Generating PROJECT_REVIEW.md…")
    generate_report(placeholders, coverage_dict)
    print("Report generated at", REPORT_PATH)

if __name__ == "__main__":
    main()
